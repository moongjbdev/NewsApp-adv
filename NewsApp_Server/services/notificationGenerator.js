const Notification = require('../models/Notification');
const User = require('../models/User');
const ReadingHistory = require('../models/ReadingHistory');
const Bookmark = require('../models/Bookmark');
const Comment = require('../models/Comment');
const { sendRealtimeNotification } = require('./socketService');

class NotificationGenerator {
  // Generate comment reply notification
  static async generateCommentReplyNotification(commentId, replyCommentId) {
    try {
      console.log(`üîî Generating reply notification for comment ${commentId}, reply ${replyCommentId}`);
      
      const comment = await Comment.findById(commentId).populate('user', 'username fullName');
      const reply = await Comment.findById(replyCommentId).populate('user', 'username fullName');
      
      if (!comment) {
        console.error(`‚ùå Parent comment ${commentId} not found`);
        return null;
      }
      
      if (!reply) {
        console.error(`‚ùå Reply comment ${replyCommentId} not found`);
        return null;
      }
      
      if (comment.user._id.toString() === reply.user._id.toString()) {
        console.log(`‚è≠Ô∏è Skipping notification - user replying to their own comment`);
        return null;
      }

      // Use upsert to prevent duplicates
      const notificationData = {
        user_id: comment.user._id,
        type: 'comment_reply',
        title: 'C√≥ ng∆∞·ªùi tr·∫£ l·ªùi b√¨nh lu·∫≠n c·ªßa b·∫°n',
        message: `${reply.user.fullName || reply.user.username} ƒë√£ tr·∫£ l·ªùi b√¨nh lu·∫≠n c·ªßa b·∫°n`,
        data: {
          article_id: comment.article_id,
          comment_id: commentId,
          reply_id: replyCommentId,
          user_id: reply.user._id,
          reply_content: reply.content.substring(0, 100)
        }
      };

      // Try to find existing notification first
      const existingNotification = await Notification.findOne({
        user_id: comment.user._id,
        type: 'comment_reply',
        $or: [
          {
            'data.comment_id': commentId.toString(),
            'data.reply_id': replyCommentId.toString()
          },
          {
            'data.comment_id': commentId,
            'data.reply_id': replyCommentId
          }
        ]
      });

      if (existingNotification) {
        console.log(`‚úÖ Duplicate reply notification prevented for comment: ${commentId}, reply: ${replyCommentId}`);
        return existingNotification;
      }

      // Create new notification
      const notification = new Notification(notificationData);
      await notification.save();
      console.log(`‚úÖ Reply notification created for comment: ${commentId}, by user: ${reply.user._id}`);
      // Emit realtime notification
      sendRealtimeNotification(comment.user._id.toString(), notification);
      return notification;
    } catch (error) {
      console.error('‚ùå Error generating comment reply notification:', error);
      throw error; // Re-throw to handle in controller
    }
  }

  // Generate comment like notification
  static async generateCommentLikeNotification(commentId, likedByUserId) {
    try {
      const comment = await Comment.findById(commentId).populate('user', 'username fullName');
      const likedByUser = await User.findById(likedByUserId).select('username fullName');
      
      if (!comment || !likedByUser || comment.user._id.toString() === likedByUserId) {
        return;
      }

      // Use upsert to prevent duplicates
      const notificationData = {
        user_id: comment.user._id,
        type: 'comment_like',
        title: 'C√≥ ng∆∞·ªùi th√≠ch b√¨nh lu·∫≠n c·ªßa b·∫°n',
        message: `${likedByUser.fullName || likedByUser.username} ƒë√£ th√≠ch b√¨nh lu·∫≠n c·ªßa b·∫°n`,
        data: {
          article_id: comment.article_id,
          comment_id: commentId,
          user_id: likedByUserId
        }
      };

      // Try to find existing notification first
      const existingNotification = await Notification.findOne({
        user_id: comment.user._id,
        type: 'comment_like',
        $or: [
          {
            'data.comment_id': commentId.toString(),
            'data.user_id': likedByUserId.toString()
          },
          {
            'data.comment_id': commentId,
            'data.user_id': likedByUserId
          }
        ]
      });

      if (existingNotification) {
        console.log('Duplicate like notification prevented for comment:', commentId, 'by user:', likedByUserId);
        return existingNotification;
      }

      // Create new notification
      const notification = new Notification(notificationData);
      await notification.save();
      console.log('Like notification created for comment:', commentId, 'by user:', likedByUserId);
      // Emit realtime notification
      sendRealtimeNotification(comment.user._id.toString(), notification);
      return notification;
    } catch (error) {
      console.error('Error generating like notification:', error);
      throw error; // Re-throw to handle in controller
    }
  }

  // Generate mention notification
  static async generateMentionNotification(commentId, mentionedUserId) {
    try {
      const comment = await Comment.findById(commentId).populate('user', 'username fullName');
      const mentionedUser = await User.findById(mentionedUserId).select('username fullName');
      
      if (!comment || !mentionedUser || comment.user._id.toString() === mentionedUserId) {
        return;
      }

      const notification = new Notification({
        user_id: mentionedUserId,
        type: 'comment_mention',
        title: 'C√≥ ng∆∞·ªùi nh·∫Øc ƒë·∫øn b·∫°n',
        message: `${comment.user.fullName || comment.user.username} ƒë√£ nh·∫Øc ƒë·∫øn b·∫°n trong b√¨nh lu·∫≠n`,
        data: {
          article_id: comment.article_id,
          comment_id: commentId,
          user_id: comment.user._id,
          comment_content: comment.content.substring(0, 100)
        }
      });

      await notification.save();
      return notification;
    } catch (error) {
      console.error('Error generating mention notification:', error);
    }
  }

  // Generate reading achievement notification
  static async generateReadingAchievementNotification(userId, achievementType, value) {
    try {
      let title, message;
      
      switch (achievementType) {
        case 'reading_streak':
          title = 'Th√†nh t√≠ch ƒë·ªçc tin t·ª©c!';
          message = `Ch√∫c m·ª´ng! B·∫°n ƒë√£ ƒë·ªçc li√™n t·ª•c ${value} ng√†y`;
          break;
        case 'total_articles':
          title = 'Th√†nh t√≠ch ƒë·ªçc tin t·ª©c!';
          message = `B·∫°n ƒë√£ ƒë·ªçc ${value} tin t·ª©c`;
          break;
        case 'total_bookmarks':
          title = 'Th√†nh t√≠ch bookmark!';
          message = `B·∫°n ƒë√£ bookmark ${value} tin t·ª©c`;
          break;
        default:
          return;
      }

      const notification = new Notification({
        user_id: userId,
        type: 'achievement',
        title,
        message,
        data: {
          achievement_type: achievementType,
          value: value
        }
      });

      await notification.save();
      return notification;
    } catch (error) {
      console.error('Error generating achievement notification:', error);
    }
  }

  // Generate daily digest notification
  static async generateDailyDigestNotification(userId) {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Get user's reading stats for today
      const readingCount = await ReadingHistory.countDocuments({
        user: userId,
        readAt: { $gte: today }
      });

      const bookmarkCount = await Bookmark.countDocuments({
        user: userId,
        bookmarkedAt: { $gte: today }
      });

      // Get user's favorite categories
      const user = await User.findById(userId);
      const favoriteCategories = user.preferences?.favoriteCategories || [];

      let message = `H√¥m nay b·∫°n ƒë√£ ƒë·ªçc ${readingCount} tin t·ª©c`;
      if (bookmarkCount > 0) {
        message += ` v√† bookmark ${bookmarkCount} tin t·ª©c`;
      }

      const notification = new Notification({
        user_id: userId,
        type: 'daily_digest',
        title: 'T√≥m t·∫Øt ho·∫°t ƒë·ªông h√¥m nay',
        message,
        data: {
          reading_count: readingCount,
          bookmark_count: bookmarkCount,
          favorite_categories: favoriteCategories
        }
      });

      await notification.save();
      return notification;
    } catch (error) {
      console.error('Error generating daily digest notification:', error);
    }
  }

  // Generate category news notification
  static async generateCategoryNewsNotification(userId, category, newsCount) {
    try {
      const user = await User.findById(userId);
      const favoriteCategories = user.preferences?.favoriteCategories || [];

      if (!favoriteCategories.includes(category)) {
        return;
      }

      const notification = new Notification({
        user_id: userId,
        type: 'category_news',
        title: 'Tin t·ª©c m·ªõi trong category y√™u th√≠ch',
        message: `C√≥ ${newsCount} tin t·ª©c ${category} m·ªõi!`,
        data: {
          category: category,
          news_count: newsCount
        }
      });

      await notification.save();
      return notification;
    } catch (error) {
      console.error('Error generating category news notification:', error);
    }
  }

  // Generate reading reminder notification
  static async generateReadingReminderNotification(userId) {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const readingCount = await ReadingHistory.countDocuments({
        user: userId,
        readAt: { $gte: today }
      });

      if (readingCount > 0) {
        return; // User has already read today
      }

      const notification = new Notification({
        user_id: userId,
        type: 'reading_reminder',
        title: 'Nh·∫Øc nh·ªü ƒë·ªçc tin t·ª©c',
        message: 'B·∫°n ch∆∞a ƒë·ªçc tin t·ª©c n√†o h√¥m nay. H√£y c·∫≠p nh·∫≠t tin t·ª©c m·ªõi nh·∫•t!',
        data: {
          reminder_type: 'daily_reading'
        }
      });

      await notification.save();
      return notification;
    } catch (error) {
      console.error('Error generating reading reminder notification:', error);
    }
  }

  // Check and generate achievement notifications
  static async checkAndGenerateAchievements(userId) {
    try {
      const user = await User.findById(userId);
      
      // Check reading streak
      const readingStreak = await this.calculateReadingStreak(userId);
      if (readingStreak >= 7 && readingStreak % 7 === 0) {
        await this.generateReadingAchievementNotification(userId, 'reading_streak', readingStreak);
      }

      // Check total articles read
      const totalArticles = await ReadingHistory.countDocuments({ user: userId });
      if (totalArticles >= 100 && totalArticles % 100 === 0) {
        await this.generateReadingAchievementNotification(userId, 'total_articles', totalArticles);
      }

      // Check total bookmarks
      const totalBookmarks = await Bookmark.countDocuments({ user: userId });
      if (totalBookmarks >= 50 && totalBookmarks % 50 === 0) {
        await this.generateReadingAchievementNotification(userId, 'total_bookmarks', totalBookmarks);
      }
    } catch (error) {
      console.error('Error checking achievements:', error);
    }
  }

  // Calculate reading streak
  static async calculateReadingStreak(userId) {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      let streak = 0;
      let currentDate = new Date(today);
      
      while (true) {
        const hasRead = await ReadingHistory.exists({
          user: userId,
          readAt: {
            $gte: currentDate,
            $lt: new Date(currentDate.getTime() + 24 * 60 * 60 * 1000)
          }
        });
        
        if (hasRead) {
          streak++;
          currentDate.setDate(currentDate.getDate() - 1);
        } else {
          break;
        }
      }
      
      return streak;
    } catch (error) {
      console.error('Error calculating reading streak:', error);
      return 0;
    }
  }

  // Clean up duplicate notifications (run periodically)
  static async cleanupDuplicateNotifications() {
    try {
      // Find and remove duplicate like notifications
      const duplicateLikes = await Notification.aggregate([
        {
          $match: {
            type: 'comment_like'
          }
        },
        {
          $group: {
            _id: {
              user_id: '$user_id',
              comment_id: '$data.comment_id',
              liked_by: '$data.user_id'
            },
            count: { $sum: 1 },
            notifications: { $push: '$_id' }
          }
        },
        {
          $match: { count: { $gt: 1 } }
        }
      ]);

      // Remove duplicates, keep the first one
      for (const duplicate of duplicateLikes) {
        const toRemove = duplicate.notifications.slice(1);
        await Notification.deleteMany({ _id: { $in: toRemove } });
        console.log(`Removed ${toRemove.length} duplicate like notifications`);
      }

      // Find and remove duplicate reply notifications
      const duplicateReplies = await Notification.aggregate([
        {
          $match: {
            type: 'comment_reply'
          }
        },
        {
          $group: {
            _id: {
              user_id: '$user_id',
              comment_id: '$data.comment_id',
              reply_id: '$data.reply_id'
            },
            count: { $sum: 1 },
            notifications: { $push: '$_id' }
          }
        },
        {
          $match: { count: { $gt: 1 } }
        }
      ]);

      // Remove duplicates, keep the first one
      for (const duplicate of duplicateReplies) {
        const toRemove = duplicate.notifications.slice(1);
        await Notification.deleteMany({ _id: { $in: toRemove } });
        console.log(`Removed ${toRemove.length} duplicate reply notifications`);
      }

      console.log('Duplicate notification cleanup completed');
    } catch (error) {
      console.error('Error cleaning up duplicate notifications:', error);
    }
  }
}

module.exports = NotificationGenerator; 